import Foundation
import XCTest
@testable import Decoder

class FunctionInterpretDoubleTest: XCTestCase {

  func testInterpretDouble_returnsNilForNonMatchingByteCount() {
    for count in 0..<MemoryLayout<Double>.size {
      for endianness: Endianness in [.big, .little] {
        XCTAssertNil(
          interpretDouble(
            bytes: Data(repeating: 0x00, count: count),
            sourceEndianness: endianness
          ),
          "Should have returned nil for incomplete binary."
        )
      }
    }
  }

  func testInterpretDouble_successfulInterpretation() {
    let bigEndianMap: [Data: Double] = [
      Data([0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 1,
      Data([0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]): 1.0000000000000002,
      Data([0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02]): 1.0000000000000004,
      Data([0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 2,
      Data([0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): -2,
      Data([0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 3,
      Data([0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 4,
      Data([0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 5,
      Data([0x40, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 6,
      Data([0x40, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 23,
      Data([0x3F, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 0.01171875,
      Data([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]): 5e-324,
      Data([0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]): 2.225073858507201e-308,
      Data([0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): 1.390671161567e-309,
      Data([0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]): 1.7976931348623157e+308,
      Data([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): +0.0,
      Data([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): -0.0,
      Data([0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): Double.infinity,
      Data([0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]): -Double.infinity,
      Data([0x40, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18]): Double.pi,
    ]
    for (bigEndianBytes, expectedValue) in bigEndianMap {
      guard let bigEndianPayload = interpretDouble(bytes: bigEndianBytes, sourceEndianness: .big) else {
        XCTFail("Should have returned a payload.")
        continue
      }
      switch bigEndianPayload {
        case .double(let actualValue):
          XCTAssertEqual(expectedValue, actualValue)
        default:
          XCTFail("Should have returned a double type payload.")
      }
      let littleEndianBytes = Data(bigEndianBytes.reversed())
      guard let littleEndianPayload = interpretDouble(bytes: littleEndianBytes, sourceEndianness: .little) else {
        XCTFail("Should have returned a payload.")
        continue
      }
      switch littleEndianPayload {
        case .double(let actualValue):
          XCTAssertEqual(expectedValue, actualValue)
        default:
          XCTFail("Should have returned a double type payload.")
      }
    }
  }

}
